/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
import { MDCComponent } from '@smui/base/component';
import { closest } from '@smui/dom/ponyfill';
import { strings } from './constants';
import { MDCSnackbarFoundation } from './foundation';
import * as util from './util';
const { SURFACE_SELECTOR, LABEL_SELECTOR, ACTION_SELECTOR, DISMISS_SELECTOR, OPENING_EVENT, OPENED_EVENT, CLOSING_EVENT, CLOSED_EVENT, } = strings;
/** MDC Snackbar */
export class MDCSnackbar extends MDCComponent {
    static attachTo(root) {
        return new MDCSnackbar(root);
    }
    initialize(announcerFactory = () => util.announce) {
        this.announce = announcerFactory();
    }
    initialSyncWithDOM() {
        this.surfaceEl = this.root.querySelector(SURFACE_SELECTOR);
        this.labelEl = this.root.querySelector(LABEL_SELECTOR);
        this.actionEl = this.root.querySelector(ACTION_SELECTOR);
        this.handleKeyDown = (event) => {
            this.foundation.handleKeyDown(event);
        };
        this.handleSurfaceClick = (event) => {
            const target = event.target;
            if (this.isActionButton(target)) {
                this.foundation.handleActionButtonClick(event);
            }
            else if (this.isActionIcon(target)) {
                this.foundation.handleActionIconClick(event);
            }
        };
        this.registerKeyDownHandler(this.handleKeyDown);
        this.registerSurfaceClickHandler(this.handleSurfaceClick);
    }
    destroy() {
        super.destroy();
        this.deregisterKeyDownHandler(this.handleKeyDown);
        this.deregisterSurfaceClickHandler(this.handleSurfaceClick);
    }
    open() {
        this.foundation.open();
    }
    /**
     * @param reason Why the snackbar was closed. Value will be passed to
     *     CLOSING_EVENT and CLOSED_EVENT via the `event.detail.reason` property.
     *     Standard values are REASON_ACTION and REASON_DISMISS, but custom
     *     client-specific values may also be used if desired.
     */
    close(reason = '') {
        this.foundation.close(reason);
    }
    getDefaultFoundation() {
        // DO NOT INLINE this variable. For backward compatibility, foundations take
        // a Partial<MDCFooAdapter>. To ensure we don't accidentally omit any
        // methods, we need a separate, strongly typed adapter variable.
        const adapter = {
            addClass: (className) => {
                this.root.classList.add(className);
            },
            announce: () => {
                this.announce(this.labelEl);
            },
            notifyClosed: (reason) => {
                this.emit(CLOSED_EVENT, reason ? { reason } : {});
            },
            notifyClosing: (reason) => {
                this.emit(CLOSING_EVENT, reason ? { reason } : {});
            },
            notifyOpened: () => {
                this.emit(OPENED_EVENT, {});
            },
            notifyOpening: () => {
                this.emit(OPENING_EVENT, {});
            },
            removeClass: (className) => {
                this.root.classList.remove(className);
            },
        };
        return new MDCSnackbarFoundation(adapter);
    }
    get timeoutMs() {
        return this.foundation.getTimeoutMs();
    }
    set timeoutMs(timeoutMs) {
        this.foundation.setTimeoutMs(timeoutMs);
    }
    get closeOnEscape() {
        return this.foundation.getCloseOnEscape();
    }
    set closeOnEscape(closeOnEscape) {
        this.foundation.setCloseOnEscape(closeOnEscape);
    }
    get isOpen() {
        return this.foundation.isOpen();
    }
    get labelText() {
        // This property only returns null if the node is a document, DOCTYPE,
        // or notation. On Element nodes, it always returns a string.
        return this.labelEl.textContent;
    }
    set labelText(labelText) {
        this.labelEl.textContent = labelText;
    }
    get actionButtonText() {
        return this.actionEl.textContent;
    }
    set actionButtonText(actionButtonText) {
        this.actionEl.textContent = actionButtonText;
    }
    registerKeyDownHandler(handler) {
        this.listen('keydown', handler);
    }
    deregisterKeyDownHandler(handler) {
        this.unlisten('keydown', handler);
    }
    registerSurfaceClickHandler(handler) {
        this.surfaceEl.addEventListener('click', handler);
    }
    deregisterSurfaceClickHandler(handler) {
        this.surfaceEl.removeEventListener('click', handler);
    }
    isActionButton(target) {
        return Boolean(closest(target, ACTION_SELECTOR));
    }
    isActionIcon(target) {
        return Boolean(closest(target, DISMISS_SELECTOR));
    }
}
//# sourceMappingURL=component.js.map